\input{project_settings}
\input{listings_settings}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% En 'titlepage.tex' se encuentra la página de título
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INDICE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\tableofcontents
\clearpage 

\lstset{style=javastyle}

\section{Ejercicio 1 - Calculadora implementada con RMI}

\emph{El código fuente y las capturas de paquetes se pueden encontrar en los directorios \dq{src} y \dq{pcaps}, respectivamente} 

~\\

El servidor de la presente aplicación publica dos servicios distintos, con el fin de emular una calculadora: \emph{SumaResta}, y \emph{MultiplicacionDivision}; el primero implementa la interfase \texttt{ISumaResta} y el segundo \texttt{IMultiplicacionDivision} (ambas interfases extienden la interfase \texttt{Remote}). 

El cliente (clase \texttt{Cliente}) consiste en un intermediario entre la aplicación de consola (clase \texttt{CLICliente}) y el servidor; el \emph{parser} de línea de comandos toma los argumentos y según el operador ingresado llama a alguno de los métods del \emph{Cliente} (\texttt{sumar}, \texttt{restar}, \texttt{multiplicar}, \texttt{dividir}). Estas operaciones son realizadas por el \textbf{servidor}, y no por el \textbf{cliente}.

A partir de las capturas realizadas con el analizador de protocolos \emph{Wireshark}, se puede deducir lo siguiente:

\begin{itemize}
    \item Las interacciones tanto del servidor (para publicar servicios) como del cliente (para consumir esos servicios) se hace a través del \textbf{RMIregistry} 
    \item RMIregistry escucha en un puerto bien conocido para ambas partes - escucha peticiones en el puerto \textbf{1099}
    \item Para recuperar el objeto remoto, el cliente primero se comunica con el RMIregistry (éste último le indica en qué puerto está escuchando el objeto remoto)
    \item El cliente recupera un \emph{objeto remoto} invocando el método \texttt{lookup} de la clase \texttt{Naming} indicándole el \emph{URI} del objeto - envía una petición al puerto de escucha que le indicó RMIregistry
    \item El \emph{URI} se compone de la dirección donde se encuentra el servidor, el puerto de escucha de RMIregistry, y el nombre del servicio publicado por el servidor
    \item Toda la comunicación de RMIregistry es a través de \textbf{TCP} 
\end{itemize}

\subsection{Numeración de paquetes de la captura \emph{pcapng}}

\emph{El archivo de la captura es \dq{rmi-sumaresta.pcapng} - abrir con Wireshark o con \texttt{tcpdump}} 

A continuación se enumeran los distintos paquetes que fluyen por la red entre el servidor y el RMIregistry en el momento en el que el primero publica los servicios. También se indican los paquetes cuándo un cliente recupera el objeto remoto, y por último los paquetes que representan el llamado a un método remoto: 

\begin{itemize}
    \item 1-29: servidor publica servicios. Para ello se comunica directamente con el RMIregistry (puerto 1099)
    \item 32-60: cliente recupera el objeto remoto que implementa la interfase \texttt{ISumaResta}. Primero se comunica con RMIregistry en el puerto 1099, y luego se comunica con el objeto remoto en el puerto 39529 
    \item 70-87: invocación de método remoto. Se comunica directamente con el objeto remoto al puerto 39529.
\end{itemize}

\section{Ejercicio 2 - RFS implementado con RMI}

Utilizando RMI, se puede implementar un \emph{sistema de archivos remotos} fácilmente. Para ello, se tomó como proyecto base la implementación realizada en el trabajo de laboratorio anterior y se lo modificó acordemente para que utilice RMI.

En esta nueva versión, la estructura del proyecto se vio fuertemente alterada; en la versión implementada con \emph{sockets}, toda la infraestructura de comunicación entre cliente y servidor fue desarrollada desde cero, enviando objetos \texttt{RFSArgument} y reaccionando según el tipo de argumento del que se trate. De esta forma se lograba transmitir alrededor de 400 MB de un archivo en 37 minutos, aproximadamente.

Utilizando RMI, el desarrollo tanto del cliente como del servidor no tiene que preocuparse por la comunicación entre estos, ya que RMI se encarga de ello. La primer modificación que se puede ver es que \textbf{las clases de \emph{stub} desaparecieron} (ya no son necesarias para esta versión). Cuando se instancia la clase \texttt{Client} (encargada de hacer las llamadas al \texttt{fileSystem}), solicita el objeto remoto publicado por el servidor a través de la clase \texttt{Naming}.

Ejecutando la misma prueba que en las versiones de RPC y la de \emph{sockets} (transferir un archivo de texto de 3.9 GB, utilizando un buffer de transferencia de 8 KB), la implementación con RMI es considerablemente superior - la transferencia del archivo demoró \textbf{solamente 33 segudos}, frente a 17 minutos de la versión de RPC y aproximadamente 37 minutos para transferir 400 MB con la versión de \emph{sockets}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{archivo-transferido-rmi.png}
    \caption{Transferencia del archivo de texto con la versión de RMI}
\end{figure}

Por otro lado, los servicios publicados con RMI no permiten trabajar con funciones que utilicen argumentos de salida o entrada/salida. Por lo tanto, la interfase \texttt{IFileSystem} tuvo que ser modificada (la operación \texttt{read}, en particular) para eliminar los argumentos de salida. En esta versión, la operación \texttt{read} recibe un archivo del cual leer y una cantidad de bytes, y devuelve un \emph{arreglo de bytes} con los datos leídos.   


\section{Ejercicio 3 - Servidores concurrentes - Comparación RPC y RMI}

El principal problema con el que tienen que lidiar los servidores concurrentes es el del \textbf{acceso a los recursos}. Este problema consiste en administrar los recursos disponbiles para que los clientes los puedan solicitar y que mantengan un estado consistente. 

Para trabajar con una situación de este tipo en un sistema distribuido implementado con Java y RMI, el lenguaje provee de la palabra reservada \texttt{synchronized}. Cuando un hilo está ejectuando un método definido como \emph{sincronizado}, todos los otros hilos que quieran ejectuar ese método \textbf{del mismo objeto} serán bloqueados (se suspende su ejecución) hasta que finalice la ejecución del primer hilo \autocite{SynchronizedMethods}

RPC y RMI son comparable en cuanto a que ambos implementan una capa de \emph{middleware} que resulta transparente para el programador. Utilizando estas herramientas, se logra desarrollar un sistema distribuido trabajando con objetos (RMI) o llamadas a funciones y registros (RPC) de forma que parecen ser locales, pero realmente se están ejectuando de forma remota. Todo el \dq{andamiaje} necesario para comunicar un cliente con un servdior (como el implementado en el trabajo de laboratorio anterior) ya es implementado por la herramienta.

Sin embargo, no se podría decir que trabajan en \emph{exactamente el mismo nivel de abstracción}, pero la diferencia no se debe a la herramienta, sino al \textbf{lenguaje para el cual están implementados} (C en el caso de RPC, y Java para RMI).  

Algunas diferencias entre RPC y RMI son las siguientes:

\begin{itemize}
    \item RMI no utiliza un lenguaje propio para definir las interfaces de las funciones y las estructuras de datos, sino que se definen como interfases de Java
    \item En RPC no se publican los servicios bajo una \emph{URL}; \texttt{rpcgen} genera el archivo \texttt{.h} con las firmas de las funciones remotas para llamarlas desde algún cliente  
    \item RMI publica objetos (que implementan la funcionalidad del servicio), los cuales serán requeridos por los clientes y las funciones remotas serán invocadas a través de los métodos del objeto remoto.
\end{itemize}


Con respecto al manejo de concurrencia de RMI, se puede verificar que crea \textbf{un hilo por referencia a objeto remoto}. Un experimento posible para demostrar esto consiste en modificar la clase \emph{SumaResta.java} del proyecto del ejercicio anterior de la siguiente manera:

\begin{lstlisting}[title={Modificar el método \texttt{suma} para poder ver el hilo en el que corre}]
    public int suma(int a, int b) {
        long threadId = Thread.currentThread().getId();
        JOptionPane.showMessageDialog(null, 
                String.format("HILO [%d]", threadId));
        return a+b;
    }
\end{lstlisting}

Si se ejecuta varias veces el método \texttt{suma} \textbf{con el mismo cliente}, se podrá ver que siempre se imprime el mismo número de hilo. Se podría ver lo mismo si el mismo cliente ejecuta otro método del objeto remoto (el método \texttt{resta}, por ejemplo).  

\section{Ejercicio 4 - Experimentos con RMI}

\emph{RMI otorga un servicio concurrente en forma automática para el acceso a objetos remotos} 
~\\

Con la modificación realizada al proyecto de la calculadora mostrada en la sección inmediatamente anterior, se puede ver que \textbf{RMI automáticamente otorga un manejo concurrente de los objetos remotos} - cada referencia a un objeto remoto es un hilo distinto en el servidor.

\emph{Las variables de instancia de un determinado objeto remoto, no se “contaminan” con sus equivalentes de otras instancias del mismo objeto a las que se está accediendo en forma concurrente (acceso sincronizado)} 
~\\

Realizando varias modificaciones a la implementación de la calculadora, se pueden realizar varios experimentos para ver que \textbf{se dan condiciones de carrera}. Para poder verlo más claramente, se debe reiniciar el servidor cada vez que se quiera hacer una nueva prueba (\emph{los códigos fuente necesarios para los experimentos se encuentran en el directorio \dq{ej4}}).

Primero se debe ejecutar \texttt{rmiregistry} y el servidor que publica los servicios de suma y resta, y multiplicación y división. Para levantar el servidor, se debe correr el siguiente comando dentro del directorio \dq{ej4}: \texttt{java -cp bin Servidor}. 

Las condiciones de carrera se pueden ver cuando se corren dos clientes a la vez, intercalando las ejecuciones. Primero se debe correr uno, con una operación de suma/resta - se mostrará un mensaje indicando el \dq{estado} del objeto remoto. Dejando ese mensaje abierto, correr el otro cliente con la operación inversa de suma/resta, y ejecutarlo hasta que finalice su ejecución. Luego correr el primero hasta que finalice, y comparar los resultados.

Probando distintas combinaciones de operaciones de suma/resta y operandos se puede ver que se obtienen distintos resultados del \dq{estado} del objeto remoto. A continuación se detalla un experimento concreto para realizar:

\begin{itemize}
    \item Correr \texttt{rmiregistry} y el servidor 
    \item Ejecutar el cliente con el comando \texttt{java -cp bin CLICliente localhost 21 + 9} - No cerrar el primer mensaje. Cuando se ejecuta una suma o una resta, el objeto remoto incrementa un contador
    \item Ejecutar otro cliente con el comando \texttt{java -cp bin CLICliente localhost 30 - 20} - Ejecutar hasta finalizar
    \item Continuar con la ejecución del primer cliente - el resultado final del estado debe ser 2
\end{itemize}

Cabe aclarar que, aunque cada cada cliente tenga \textbf{referencia} al objeto remoto (en este caso, al objeto de la clase \texttt{SumaResta} publicado por el servidor), sigue siendo el mismo objeto, por lo tanto hay un \textbf{único estado}. Para evitar estas condiciones de carrera, se podría modificar los métodos de suma y de resta de tal forma que solamente un cliente los ejecute por vez (que su ejecución sea atómica); de esta forma el estado no terminaría en valores inesperados.  


\section{Ejercicio 5 - Implementación de Timeout}

Al tener que tratar con servicios remotos el cliente se encuentra atado a la \textbf{disponibilidad} del servidor en cueanto a tiempo para poder atender sus peticiones. Por lo tanto, lo que puede hacer el cliente es fijar un tiempo de espera o \textbf{timeout} para las peticiones que le realice al servidor. De esta forma no se queda esperando indefinidamente a que le respondan.

Para implementar el timeout en el cliente debemos crear una clase \texttt{TimeoutFactory} que cree los sockets de cliente y servidor contemplando un timeout especificado. Y luego hacer que el cliente adopte precauciones con respecto a los tiempos de espera.

\begin{lstlisting}[title={Socket factory que contempla el \textbf{timeout} especificado}]
class TimeoutFactory extends RMISocketFactory {

    private int timeout;

    public TimeoutFactory(int timeout) {
        this.timeout = timeout;
    }

    public Socket createSocket(String host, int port) throws IOException {
        Socket ret = getDefaultSocketFactory().createSocket(host, port);
        ret.setSoTimeout(timeout * 1000);
        return ret;
    }

    public ServerSocket createServerSocket(int port) throws IOException {
        return getDefaultSocketFactory().createServerSocket(port);
    }
}
\end{lstlisting}

Luego, en el cliente, antes de setear el valor del host al cual conectarse para requerir los servicios:

\begin{lstlisting}[title={Utilizar la \texttt{TimeoutFactory} como default para la creación de sockets en el constructor de Cliente}]
    public Cliente(String host) {
        try {
            RMISocketFactory.setSocketFactory(
                new TimeoutFactory(5)
            );
        } catch(IOException e){
            e.printStackTrace();
        }
        this.setHost(host);
    }
\end{lstlisting}

Al utlizar esta nueva implementación se le agregó una pausa de 6 segundos en el servicio de Suma. Luego se ejecutó el cliente requiriendo la suma. Como la espera máxima fijada es de 5 segundos, el servicio falla. Cuando la espera se quita el servicio finaliza exitosamente.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FIN DOCUMENTO, AHORA REFERENCIAS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\printbibliography

\end{document}

